**1. Are there any sub-optimal choices( or short cuts taken due to limited time ) in your implementation?**

While I believe that my implementation is fairly well-written, there were definitely some short-cuts made on my end due to the limited time of the assignment.  This stems from the fact that although I have some experience in frontend technology and specific frameworks for both front and backend programs, I have not used Springboot nor React specifically.  Because of this, as well as learning both of these frameworks in a relatively short period of time, I included many of the more basic ways to complete tasks.  One example of this is how, in my backend, I have different functions for making the api requests to Coinbase and Binance.  This is because each exchange returns json files that include slightly different formats.  While I know there is a way to parse a json file, in my implementation, I took a shortcut and hard-coded the way to pull the price from each exchange's json file.  Another simple shortcut was how I formed the string of data that my backend returns.  I again hard-coded each of the 12 data points with their own line that appends that data onto the string instead of using a more generic loop.  

Lastly, the biggest shortcut that my implementation has involves the way that my frontend and backend communicate.  In my implementation, my backend and frontend are technically running as two separate servers running on different ports on localhost.  So, when my frontend server makes its request to my backend, which then makes requests to the two exchanges, a Cross-Origin Resource Sharing (CORS) policy is violated, which prevents essentially that from occurring as a means of ensuring web security.  What I did to overcome this issue was include the annotation @CrossOrigin on line 15 of ChainalysisTestApplication.java.  What this does is essentially allow for this communication to exist.  The correct implementation of this program would have the backend sending all the html and css files to the frontend so that everything is running on the same server, thus not violating any important security protocols.


**2. Is any part of it over-designed? (It is fine to over-design to showcase your skills as long as you are clear about it)**

In my understanding and implementation, much of the function of the backend is redundant.  Essentially, all that my backend is doing is making a series of api requests to servers, doing simple math, and sending that data to the frontend through its own request. For a project as straightforward as this, I do not see anything wrong with the frontend simply making those api calls to the exchanges.  This would not only make the program simpler and make errors less likely, it would also fix the CORS policy that my current implementation violates.

**3. If you have to scale your solution to 100 users/second traffic what changes would you make, if any?**

In order to scale my implementation to 100 users/second, I would try to limit the number of requests that my backend is making to the exchanges.  Currently, my frontend, which is technically unique for each user, is constantly making calls to the backend for the data, as you can see in the video demonstration linked in the README file.  Because every request to the backend is actually a series of api requests to the exchanges, at 100 users per second, this would amount to tens of thousands of requests being made every minute, many of which would be returning the exact same set of data.  To reduce the number of requests, there are two easy changes I could make.  The first would be to simply reduce the speed at which the frontend makes requests for data.  If it was changed to once every minute instead of immediately upon receiving the data from the previous request, this would reduce the total possible number of requests considerably.  The better method, and one I would first implement, is to maintain one set of data in the backend, possibly in an sql database, that updates the prices every minute or so.  Then when the frontend loads the webpage, it will request the data from that database instead of having the backend make new requests to the exchanges.  This would set a firm limit on the total number of requests to the exchanges at 6 every minute.

**4. What are some other enhancements you would have made, if you had more time to do this implementation.**

Besides addressing the shortcuts I made that were described in question 1, I would first try to neaten up and simplify my code.  While everything is consistent, the data structures used and ways data is stored and then accessed, is slightly complex for what is actually being done.  The first thing that comes to mind is how all the prices are stored in maps once obtained.  Then while determining the recommendations, I have to be careful in matching the keys of the maps and checking if they are buy or sell prices.  It would be much cleaner if the values were simply stored in arrays that I would have just been able to index into to compare the values.  On the frontend side, any additional time would have gone into making the webpage more visually appealing and complex.  Right now, it is very simply structured with basic and flat colors.  While altering the look would not change the functionality of the site and whether or not the program worked, it would have been another way to demonstrate my coding ability.
